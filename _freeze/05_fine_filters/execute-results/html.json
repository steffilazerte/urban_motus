{
  "hash": "10b355b52926d8e85a420e5ff81ace17",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Fine-scale Filtering\neval: false\nfreeze: auto\n---\n\n\nHere we perform fine-scale filtering which involves more assessments of potential issues. \n\n## Setup\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"XX_setup.R\")\n```\n:::\n\n\n## Custom tables\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncustom_hits <- function(db) {\n  # Replacement for NULL tsEnd values (i.e. today plus change)\n  max_ts <- round(as.numeric(Sys.time()) + 1000)\n  \n  # Get Receivers\n  r <- tbl(db, \"recvDeps\") |> \n    select(\"deviceID\", \"recvDeployID\" = \"deployID\", \"tsStartRecv\" = \"tsStart\", \"tsEndRecv\" = \"tsEnd\",\n           \"recvType\" = \"receiverType\") |>\n    mutate(tsEndRecv = if_else(is.na(tsEndRecv), max_ts, tsEndRecv))\n  \n  # Get tags\n  t <- tbl(db, \"tagDeps\") |> \n    select(\"tagID\", \"tagDeployID\" = \"deployID\", \"speciesID\", \"tsStartTag\" = \"tsStart\", \"tsEndTag\" = \"tsEnd\") |>\n    mutate(tsEndTag = if_else(is.na(tsEndTag), max_ts, tsEndTag))  \n  \n  # Combine with the rest - And OMIT BAD filtered observations from previous step\n  tbl(db, \"hits\") |>\n    select(-\"validated\") |>\n    # Filter out \"Bad runs\" from previous step\n    left_join(tbl(db, \"bad_data\"), by = c(\"runID\", \"tagID\")) |>\n    filter(is.na(BAD)) |>\n    select(-\"BAD\")\n    # Add in runs and motusFilters\n    left_join(tbl(db, \"runs\") |> select(\"runID\", \"motusFilter\", \"tagID\" = \"motusTagID\"), by = \"runID\") |>\n    # Add in tags by tagID *and* overlap of start/end of tag deployment with the beginning of a run\n    left_join(t, by = join_by(tagID, between(ts, tsStartTag, tsEndTag))) |>\n    # Add in batches by batchID (to get the deviceID)\n    left_join(tbl(db, \"batches\") |> select(\"batchID\", \"motusDeviceID\"), by = \"batchID\") |>\n    # Add in receivers by deviceID *and* overlap of receiver deployment time with the beginning of a run\n    left_join(r, by = join_by(motusDeviceID == deviceID, between(ts, tsStartRecv, tsEndRecv))) |>\n    # Keep only relevant data\n    select(-\"batchID\", -\"tsStartRecv\", -\"tsEndRecv\", -\"tsStartTag\", -\"tsEndTag\") |>\n    rename(\"recvDeciveID\" = \"motusDeviceID\")\n}\n\nhits <- map(dbs, custom_hits)\n```\n:::\n\n\n\n## Noise\n\nTODO: use a custom noise filter?\n\nHere is the first and simplest filter, we'll gather all the run/tag combinations\nwith a `motusFilter` value of 0.\n\nSee [in-depth detections filtering](https://motuswts.github.io/motus/articles/filtering.html) and [A tool to identify probable false positive detections](https://motuswts.github.io/motus/articles/identifying-false-positives.html) for more details.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnoise <- imap(dbs, \\(x, y) {\n  tbl(x, \"runs\") |> \n    select(runID, motusTagID, probability = motusFilter) |>\n    filter(probability == 0) |>\n    mutate(proj_id = y) |>\n    collect()\n})\n```\n:::\n\n\n## Hits\n\nThese are based on notes from Amie MacDonald's scripts\n\nHere we'll use a modified version of the motusFilter\n\n- Hits from SENSORGNOME stations with a freqSD > 0.1 will be considered 'bad' data\n\n\nThen we'll \n\n- Omit individual tags with only bad data using a modified version of the motusFilter\n- Calculate the proportion of good/bad data per tag, per receiver, per day, \n  omit those where less than half are 'good'\n\nCollect all runs relating to tag deployments with *only* bad motusFilter data (i.e. all 0)\n\n::: {.cell}\n\n```{.r .cell-code}\nnoise_tags <- map(hits, \\(x) {\n  x |>\n    mutate(motusFilter = if_else(recvType == \"SENSORGNOME\" & freqSD > 0.1, 0, motusFilter)) |>\n    filter(sum(motusFilter) == 0, .by = c(\"tagID\", \"tagDeployID\"))\n})\n```\n:::\n\n\n\n\nUse a ts date for now (60 * 60 * 24) seconds in a day, so we can categorize\nts by numeric UTC date.\n\n::: {.cell}\n\n```{.r .cell-code}\nnoise_quality <- map(hits, \\(x) {\n  x |>\n    mutate(motusFilter = if_else(recvType == \"SENSORGNOME\" & freqSD > 0.1, \n                                 0, motusFilter),\n           ts_date = floor(ts / (60 * 60 * 24))) |>\n    select(runID, tagID, tagDeployID, recvDeployID, ts_date, motusFilter) |>\n    group_by(tagID, tagDeployID, recvDeployID, ts_date) |>\n    mutate(p_good = sum(motusFilter) / n(), .groups = \"drop\") |>\n    ungroup() |>\n    filter(p_good <= 0.5) |>\n    select(\"runID\", \"tagID\", \"tagDeployID\")\n})\n```\n:::\n\n\n\n\n\n\n## Tags\n\nThere are two broad classes of tags, Lotek and CTT. \nThese tags [have different properties and are processed differently](https://motuswts.github.io/motus/articles/identifying-false-positives.html?q=Lotek%20nanotags#introduction), so \ncare should be taken to treat them differently. \n\nLet's first take a look a see how many tags of each type we have\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(dbs[[1]], \"tags\") |>\n  filter(projectID %in% projects) |>\n  select(projectID, manufacturer, tagID) |>\n  distinct() |>\n  count(projectID, manufacturer) |>\n  collect() |>\n  gt()\n```\n:::\n\n\nSo we mostly have Lotek tags (which much of the filtering suggestions have been based on),\nbut we do have two projects with CTT tags to consider.\n\n\n## Ambiguous detections\n\nTODO: Needs to be done post-filtering (as much as possible)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nambig <- map(dbs, \\(x) tbl(x, \"allruns\") |>\n               select(ambigID, motusTagID) |>\n               filter(!is.na(ambigID)) |>\n                distinct() |>\n                collect()) |>\n  list_rbind(names_to = \"proj_id\")\n```\n:::\n\n\n\n\n## Wrap up\nDisconnect from the databases\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk(dbs, dbDisconnect)\n```\n:::\n\n\n## Reproducibility\n\n\n:::{.callout-note collapse=true}\n### Session Info\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::session_info()\n```\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}