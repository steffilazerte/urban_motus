{
  "hash": "54da98facc2a652244d25379be23354a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Fine-scale Filtering\neval: false\nfreeze: auto\n---\n\n\nHere we perform fine-scale filtering which involves more assessments of potential issues. \n\n## Setup\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"XX_setup.R\")\n```\n:::\n\n\n### Custom tables\n\n::: {.cell}\n\n:::\n\n\nGet the custom hit tables for all databases (filtered to omit 'bad' data from previous step)\n\n::: {.cell}\n\n```{.r .cell-code}\nhits <- map(dbs, custom_hits)\n\nhits_df <- imap(hits, \\(x, y) {\n  d <- collect(x)\n  write_csv(d, paste0(\"Data/Datasets/hits_\", y, \".csv\"))\n  d\n})\n\nwrite_rds(hits_df, \"Data/Datasets/hits_full.rds\")\n```\n:::\n\n\n\n\n## Hit based filtering\n\nThese are based on notes from Amie MacDonald's scripts\n\nHere we'll use a modified version of the motusFilter\n\n- Hits from SENSORGNOME stations with a freqSD > 0.1 will be considered 'bad' data\n\n\nThen we'll \n\n- Omit individual tags with only bad data using a modified version of the motusFilter\n- Calculate the proportion of good/bad data per tag, per receiver, per day, \n  omit those where less than half are 'good'\n\nCollect all runs relating to tag deployments with *only* bad motusFilter data (i.e. all 0)\n\n::: {.cell}\n\n```{.r .cell-code}\nnoise_tags <- map(hits, \\(x) {\n  x |>\n    mutate(motusFilter = if_else(recvType == \"SENSORGNOME\" & freqSD > 0.1, 0, motusFilter)) |>\n    summarize(motusFilter = sum(motusFilter, na.rm = TRUE), .by = c(\"tagID\", \"tagDeployID\")) |>\n    filter(motusFilter == 0) |>\n    select(\"tagID\", \"tagDeployID\")\n})\n```\n:::\n\n\nUse a ts date for now (60 * 60 * 24) seconds in a day, so we can categorize\nts by numeric UTC date.\n\n::: {.cell}\n\n```{.r .cell-code}\nnoise_quality <- map(hits, \\(x) {\n  x |>\n    mutate(motusFilter = if_else(recvType == \"SENSORGNOME\" & freqSD > 0.1, \n                                 0, motusFilter),\n           ts_date = floor(ts / (60 * 60 * 24))) |>\n    select(runID, tagID, tagDeployID, recvDeployID, ts_date, motusFilter) |>\n    group_by(tagID, tagDeployID, recvDeployID, ts_date) |>\n    mutate(p_good = sum(motusFilter, na.rm = TRUE) / n(), .groups = \"drop\") |>\n    ungroup() |>\n    filter(p_good <= 0.5) |>\n    select(\"runID\", \"tagID\", \"tagDeployID\") |>\n    distinct()\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal <- map2(hits, noise_quality, \\(x, y) anti_join_quick(x, y))\nfinal <- map2(final, noise_tags, \\(x, y) {\n   left_join(x, select(y, \"tagID\", \"tagDeployID\") |> mutate(bad = TRUE), \n             by = c(\"tagID\", \"tagDeployID\")) |>\n    filter(!is.n(bad)) |>\n    select(-\"bad\")\n})\n```\n:::\n\n\n\n## Collect to CSV\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull <- imap(final, \\(x, y) {\n  d <- collect(x)\n  write_csv(d, paste0(\"Datasets/hits_\", y, \".csv\"))\n  d\n})\n\nwrite_rds(full, \"hits_full.rds\")\n```\n:::\n\n\n\n\n## Noise\n\n### Tags\n\nThere are two broad classes of tags, Lotek and CTT. \nThese tags [have different properties and are processed differently](https://motuswts.github.io/motus/articles/identifying-false-positives.html?q=Lotek%20nanotags#introduction), so \ncare should be taken to treat them differently. \n\nLet's first take a look a see how many tags of each type we have\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tbl(dbs[[1]], \"tags\") |>\n#   filter(projectID %in% projects) |>\n#   select(projectID, manufacturer, tagID) |>\n#   distinct() |>\n#   count(projectID, manufacturer) |>\n#   collect() |>\n#   gt()\n```\n:::\n\n\nSo we mostly have Lotek tags (which much of the filtering suggestions have been based on),\nbut we do have two projects with CTT tags to consider.\n\n### Motus Filter etc.\n\nTODO: use a custom noise filter?\n\nHere is the first and simplest filter, we'll gather all the run/tag combinations\nwith a `motusFilter` value of 0.\n\nSee [in-depth detections filtering](https://motuswts.github.io/motus/articles/filtering.html) and [A tool to identify probable false positive detections](https://motuswts.github.io/motus/articles/identifying-false-positives.html) for more details.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# noise <- imap(dbs, \\(x, y) {\n#   tbl(x, \"runs\") |> \n#     select(runID, motusTagID, probability = motusFilter) |>\n#     filter(probability == 0) |>\n#     mutate(proj_id = y) |>\n#     collect()\n# })\n```\n:::\n\n\n## Ambiguous detections\n\nTODO: Needs to be done post-filtering (as much as possible)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ambig <- map(dbs, \\(x) tbl(x, \"runs\") |>\n#                select(ambigID, motusTagID) |>\n#                filter(!is.na(ambigID)) |>\n#                 distinct() |>\n#                 collect()) |>\n#   list_rbind(names_to = \"proj_id\")\n```\n:::\n\n\n\n## Wrap up\nDisconnect from the databases\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk(dbs, dbDisconnect)\n```\n:::\n\n\n## Reproducibility\n\n\n:::{.callout-note collapse=true}\n### Session Info\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::session_info()\n```\n:::\n:::\n\n",
    "supporting": [
      "05_fine_filters_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}